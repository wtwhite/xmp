// None of the myriad existing functions for creating temporary files (e.g. tmpnam(), tempnam(), _tempnam(),
// mktemp(), mkstemp(), tmpfile()) has all of the following desirable properties:
//
// 1. No race condition between name generation and file creation
// 2. Portable (at least between Unix and Windows)
// 3. Configurable directory location
//
// So I'll make my own.  Technically it won't guarantee freedom from race conditions either, since it only
// returns a name -- but I've made efforts to ensure this works, even in the trickiest case where we have
// multiple computers on a network all creating temporary files in the same dir on a shared mount.
//
// This is NOT a general-purpose temporary file creation system.  We are only interested in a single file *path* that
// is certain not to be generated by other processes run concurrently with this process, whether they be part of
// the same MPI job (i.e. a different rank) or a totally separate invocation.

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <ctype.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <assert.h>
#include "common.h"
#ifdef TARGETMULTI
#include "mpi.h"
#endif	// TARGETMULTI

#ifdef _WIN32
#include <process.h>		// For getpid()
#define WIN32_LEAN_AND_MEAN	// Don't include several headers including winsock.h -- handy if we decide on Winsock 2, which needs the incompatible winsock2.h
#include <windows.h>		// If we don't include this, none of the Winsock functions are found at link time...
#include <winsock.h>		// For gethostname()
#define PATHSEP '\\'
#else	// not _WIN32
#include <unistd.h>			// For getpid(), gethostname()
#define PATHSEP '/'
#endif	// not _WIN32
#ifdef __blrts__
#include <rts.h>			// For BlueGene/L's rts_get_jobid()
#endif	// __blrts__

// "Tame" a string into a form suitable for use as a fairly portable filesystem path.  Specifically, replace all
// spaces with underscores, replace all colons with hyphens, and strip nonprintable characters (e.g. '\n').
// Since we replace colons, you must not use an absolute Windows-style path containing a drive specification!
void TameFilename(char *fname) {
	char *p = fname;

	for (; *fname; ++fname) {
		if (*fname == ' ') {
			*p++ = '_';
		} else if (*fname == ':') {
			*p++ = '-';		// Windows won't tolerate a ':' in a path because it looks like a drive
		} else if (!isprint(*fname)) {
			// Skip this character
		} else if (isalnum(*fname) || *fname == '/' || *fname == '\\' || *fname == '.' || *fname == '-') {
			// Any alphanumeric character, period, hyphen or path separator is taken unchanged.
			*p++ = *fname;
		} else {
			// Replace unusual printable characters with '_' to avoid shell quoting issues
			*p++ = '_';
		}
	}

	*p = 0;
}

// Explicitly allows path to be NULL, in which case 0 is of course returned.
int DirectoryExists(char *path) {
	struct stat statbuf;

	return path && !stat(path, &statbuf) && (statbuf.st_mode & S_IFDIR);
}

// basePath can be NULL, in which case we will try $TMP, $TMPDIR, $TEMP, /tmp and the current directory, in that order.
//HACK: The caller must ensure the buffer is large enough.  (It would have been nice to use snprintf() and take
// a bufLen parameter, but not all platforms support snprintf() -- e.g. Win32 doesn't, and its _sprintf_s() is
// not *quite* the same).
//TODO: On Windows, use some Win32 API function to get the default temporary file path.
void GenerateTempFileName(char *basePath, char *baseName, char *buf) {
	time_t t;
	int pid = getpid();		// Some platforms have a pid_t type, but we're gonna print it with %d so it better be convertible to int!
	char hostName[257];		// Apparently an IP hostname is always <= 255 chars.
#ifdef _WIN32
	WSADATA wsaData;
#endif	// _WIN32
#ifdef TARGETMULTI
	int rank;
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
#endif	// TARGETMULTI

	time(&t);

	// Find an appropriate directory.
	if (!DirectoryExists(basePath)) {
		basePath = getenv("TMP");
		if (!DirectoryExists(basePath)) {
			basePath = getenv("TMPDIR");
			if (!DirectoryExists(basePath)) {
				basePath = getenv("TEMP");			// Used on Windows it seems.
				if (!DirectoryExists(basePath)) {
					basePath = "/tmp";
					if (!DirectoryExists(basePath)) {
						basePath = ".";
						if (!DirectoryExists(basePath)) {
							fprintf(stderr, "Could not find a directory to use as the temporary directory!\n");
							exit(1);
						}
					}
				}
			}
		}
	}

#ifdef __blrts__
	// BlueGene/L does not support a sensible gethostname() call -- instead we'll use the integer job ID field.
	// Remember, all we want is to provide a unique name.
	sprintf(hostName, "job%d", rts_get_jobid());
#else	// not __blrts__
	// Most environments support gethostname(), but BG/L does not.  Instead, use its bgl_personality structure
	// to get the partition name, which serves the same purpose -- it will be different for different jobs run
	// at the same time.
#ifdef _WIN32
	// Need to initialise the Winsock library.  Yes, this can be done multiple times without harm, so it doesn't
	// matter if the calling code has already called it.
	if (WSAStartup(0x0101, &wsaData)) {
		fprintf(stderr, "Failed to initialise Winsock!\n");
		exit(1);
	}
#endif	// _WIN32

	hostName[sizeof hostName - 1] = 0;
	if (gethostname(hostName, sizeof hostName)) {
		perror("gethostname() failed");
		exit(1);
	}

	if (hostName[sizeof hostName - 1]) {
		fprintf(stderr, "gethostname() returned a result that could not fit in the buffer!\n");
		exit(1);
	}

#ifdef _WIN32
	// Need to uninitialise the Winsock library.  Yes, this can be done multiple times without harm, so it doesn't
	// matter if the calling code has already called it.
	WSACleanup();
#endif	// _WIN32
#endif	// not __blrts__

	// ctime() introduces spaces, colons and a trailing '\n', but TameFilename() will fix all that.
	sprintf(buf,
		"%s%c%s.%s.%s.pid%d"
#ifdef TARGETMULTI
		".rank%d"
#endif	// TARGETMULTI
		".TMP",
		basePath,
		PATHSEP,
		baseName,
		hostName,
		ctime(&t),
		pid
#ifdef TARGETMULTI
		, rank
#endif	// TARGETMULTI
	);

	TameFilename(buf + strlen(basePath) + 1);		// Only transform the basename -- on Windows, we need colons preserved in the absolute path!
}
